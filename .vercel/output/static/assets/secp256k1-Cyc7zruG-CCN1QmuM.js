import{n as Yt,o as _t,d as Wt,J as Mt,e as Gt,T as Jt,a as qt,u as Xt}from"./index-ml4ASIQF.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt(0),pt=BigInt(1),Qt=BigInt(2);function et(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function ct(r){if(!et(r))throw new Error("Uint8Array expected")}const tr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ot(r){ct(r);let e="";for(let t=0;t<r.length;t++)e+=tr[r[t]];return e}function Pt(r){const e=r.toString(16);return e.length&1?`0${e}`:e}function xt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}const _={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Rt(r){if(r>=_._0&&r<=_._9)return r-_._0;if(r>=_._A&&r<=_._F)return r-(_._A-10);if(r>=_._a&&r<=_._f)return r-(_._a-10)}function it(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const f=Rt(r.charCodeAt(i)),u=Rt(r.charCodeAt(i+1));if(f===void 0||u===void 0){const o=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+i)}n[s]=f*16+u}return n}function rt(r){return xt(ot(r))}function St(r){return ct(r),xt(ot(Uint8Array.from(r).reverse()))}function st(r,e){return it(r.toString(16).padStart(e*2,"0"))}function It(r,e){return st(r,e).reverse()}function rr(r){return it(Pt(r))}function V(r,e,t){let n;if(typeof e=="string")try{n=it(e)}catch(i){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${i}`)}else if(et(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(`${r} expected ${t} bytes, got ${s}`);return n}function ut(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];ct(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}function er(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function nr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function or(r){let e;for(e=0;r>Ut;r>>=pt,e+=1);return e}function ir(r,e){return r>>BigInt(e)&pt}function sr(r,e,t){return r|(t?pt:Ut)<<BigInt(e)}const vt=r=>(Qt<<BigInt(r-1))-pt,yt=r=>new Uint8Array(r),Nt=r=>Uint8Array.from(r);function kt(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=yt(r),s=yt(r),i=0;const f=()=>{n.fill(1),s.fill(0),i=0},u=(...p)=>t(s,n,...p),o=(p=yt())=>{s=u(Nt([0]),p),n=u(),p.length!==0&&(s=u(Nt([1]),p),n=u())},c=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let p=0;const y=[];for(;p<e;){n=u();const O=n.slice();y.push(O),p+=n.length}return ut(...y)};return(p,y)=>{f(),o(p);let O;for(;!(O=y(c()));)o();return f(),O}}const fr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||et(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function lt(r,e,t={}){const n=(s,i,f)=>{const u=fr[i];if(typeof u!="function")throw new Error(`Invalid validator "${i}", expected function`);const o=r[s];if(!(f&&o===void 0)&&!u(o,r))throw new Error(`Invalid param ${String(s)}=${o} (${typeof o}), expected ${i}`)};for(const[s,i]of Object.entries(e))n(s,i,!1);for(const[s,i]of Object.entries(t))n(s,i,!0);return r}const ar=Object.freeze(Object.defineProperty({__proto__:null,abytes:ct,bitGet:ir,bitLen:or,bitMask:vt,bitSet:sr,bytesToHex:ot,bytesToNumberBE:rt,bytesToNumberLE:St,concatBytes:ut,createHmacDrbg:kt,ensureBytes:V,equalBytes:er,hexToBytes:it,hexToNumber:xt,isBytes:et,numberToBytesBE:st,numberToBytesLE:It,numberToHexUnpadded:Pt,numberToVarBytesBE:rr,utf8ToBytes:nr,validateObject:lt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const T=BigInt(0),$=BigInt(1),Q=BigInt(2),ur=BigInt(3),mt=BigInt(4),Ht=BigInt(5),$t=BigInt(8);BigInt(9);BigInt(16);function z(r,e){const t=r%e;return t>=T?t:e+t}function cr(r,e,t){if(t<=T||e<T)throw new Error("Expected power/modulo > 0");if(t===$)return T;let n=$;for(;e>T;)e&$&&(n=n*r%t),r=r*r%t,e>>=$;return n}function C(r,e,t){let n=r;for(;e-- >T;)n*=n,n%=t;return n}function Et(r,e){if(r===T||e<=T)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=z(r,e),n=e,s=T,i=$;for(;t!==T;){const f=n/t,u=n%t,o=s-i*f;n=t,t=u,s=i,i=o}if(n!==$)throw new Error("invert: does not exist");return z(s,e)}function lr(r){const e=(r-$)/Q;let t,n,s;for(t=r-$,n=0;t%Q===T;t/=Q,n++);for(s=Q;s<r&&cr(s,e,r)!==r-$;s++);if(n===1){const f=(r+$)/mt;return function(u,o){const c=u.pow(o,f);if(!u.eql(u.sqr(c),o))throw new Error("Cannot find square root");return c}}const i=(t+$)/Q;return function(f,u){if(f.pow(u,e)===f.neg(f.ONE))throw new Error("Cannot find square root");let o=n,c=f.pow(f.mul(f.ONE,s),t),p=f.pow(u,i),y=f.pow(u,t);for(;!f.eql(y,f.ONE);){if(f.eql(y,f.ZERO))return f.ZERO;let O=1;for(let m=f.sqr(y);O<o&&!f.eql(m,f.ONE);O++)m=f.sqr(m);const L=f.pow(c,$<<BigInt(o-O-1));c=f.sqr(L),p=f.mul(p,L),y=f.mul(y,c),o=O}return p}}function dr(r){if(r%mt===ur){const e=(r+$)/mt;return function(t,n){const s=t.pow(n,e);if(!t.eql(t.sqr(s),n))throw new Error("Cannot find square root");return s}}if(r%$t===Ht){const e=(r-Ht)/$t;return function(t,n){const s=t.mul(n,Q),i=t.pow(s,e),f=t.mul(n,i),u=t.mul(t.mul(f,Q),i),o=t.mul(f,t.sub(u,t.ONE));if(!t.eql(t.sqr(o),n))throw new Error("Cannot find square root");return o}}return lr(r)}const hr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function gr(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=hr.reduce((n,s)=>(n[s]="function",n),e);return lt(r,t)}function pr(r,e,t){if(t<T)throw new Error("Expected power > 0");if(t===T)return r.ONE;if(t===$)return e;let n=r.ONE,s=e;for(;t>T;)t&$&&(n=r.mul(n,s)),s=r.sqr(s),t>>=$;return n}function yr(r,e){const t=new Array(e.length),n=e.reduce((i,f,u)=>r.is0(f)?i:(t[u]=i,r.mul(i,f)),r.ONE),s=r.inv(n);return e.reduceRight((i,f,u)=>r.is0(f)?i:(t[u]=r.mul(i,t[u]),r.mul(i,f)),s),t}function Zt(r,e){const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function wr(r,e,t=!1,n={}){if(r<=T)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:s,nByteLength:i}=Zt(r,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=dr(r),u=Object.freeze({ORDER:r,BITS:s,BYTES:i,MASK:vt(s),ZERO:T,ONE:$,create:o=>z(o,r),isValid:o=>{if(typeof o!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);return T<=o&&o<r},is0:o=>o===T,isOdd:o=>(o&$)===$,neg:o=>z(-o,r),eql:(o,c)=>o===c,sqr:o=>z(o*o,r),add:(o,c)=>z(o+c,r),sub:(o,c)=>z(o-c,r),mul:(o,c)=>z(o*c,r),pow:(o,c)=>pr(u,o,c),div:(o,c)=>z(o*Et(c,r),r),sqrN:o=>o*o,addN:(o,c)=>o+c,subN:(o,c)=>o-c,mulN:(o,c)=>o*c,inv:o=>Et(o,r),sqrt:n.sqrt||(o=>f(u,o)),invertBatch:o=>yr(u,o),cmov:(o,c,p)=>p?c:o,toBytes:o=>t?It(o,i):st(o,i),fromBytes:o=>{if(o.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${o.length}`);return t?St(o):rt(o)}});return Object.freeze(u)}function Ft(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Ct(r){const e=Ft(r);return e+Math.ceil(e/2)}function mr(r,e,t=!1){const n=r.length,s=Ft(e),i=Ct(e);if(n<16||n<i||n>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);const f=t?rt(r):St(r),u=z(f,e-$)+$;return t?It(u,s):st(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Er=BigInt(0),wt=BigInt(1);function br(r,e){const t=(s,i)=>{const f=i.negate();return s?f:i},n=s=>{const i=Math.ceil(e/s)+1,f=2**(s-1);return{windows:i,windowSize:f}};return{constTimeNegate:t,unsafeLadder(s,i){let f=r.ZERO,u=s;for(;i>Er;)i&wt&&(f=f.add(u)),u=u.double(),i>>=wt;return f},precomputeWindow(s,i){const{windows:f,windowSize:u}=n(i),o=[];let c=s,p=c;for(let y=0;y<f;y++){p=c,o.push(p);for(let O=1;O<u;O++)p=p.add(c),o.push(p);c=p.double()}return o},wNAF(s,i,f){const{windows:u,windowSize:o}=n(s);let c=r.ZERO,p=r.BASE;const y=BigInt(2**s-1),O=2**s,L=BigInt(s);for(let m=0;m<u;m++){const a=m*o;let d=Number(f&y);f>>=L,d>o&&(d-=O,f+=wt);const h=a,E=a+Math.abs(d)-1,B=m%2!==0,A=d<0;d===0?p=p.add(t(B,i[h])):c=c.add(t(A,i[E]))}return{p:c,f:p}},wNAFCached(s,i,f,u){const o=s._WINDOW_SIZE||1;let c=i.get(s);return c||(c=this.precomputeWindow(s,o),o!==1&&i.set(s,u(c))),this.wNAF(o,c,f)}}}function jt(r){return gr(r.Fp),lt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Zt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Br(r){const e=jt(r);lt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:xr,hexToBytes:Sr}=ar,tt={Err:class extends Error{constructor(r=""){super(r)}},_parseInt(r){const{Err:e}=tt;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");const t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:xr(n),l:r.subarray(t+2)}},toSig(r){const{Err:e}=tt,t=typeof r=="string"?Sr(r):r;ct(t);let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:s,l:i}=tt._parseInt(t.subarray(2)),{d:f,l:u}=tt._parseInt(i);if(u.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:f}},hexFromSig(r){const e=c=>Number.parseInt(c[0],16)&8?"00"+c:c,t=c=>{const p=c.toString(16);return p.length&1?`0${p}`:p},n=e(t(r.s)),s=e(t(r.r)),i=n.length/2,f=s.length/2,u=t(i),o=t(f);return`30${t(f+i+4)}02${o}${s}02${u}${n}`}},W=BigInt(0),j=BigInt(1);BigInt(2);const Tt=BigInt(3);BigInt(4);function Ir(r){const e=Br(r),{Fp:t}=e,n=e.toBytes||((m,a,d)=>{const h=a.toAffine();return ut(Uint8Array.from([4]),t.toBytes(h.x),t.toBytes(h.y))}),s=e.fromBytes||(m=>{const a=m.subarray(1),d=t.fromBytes(a.subarray(0,t.BYTES)),h=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:d,y:h}});function i(m){const{a,b:d}=e,h=t.sqr(m),E=t.mul(h,m);return t.add(t.add(E,t.mul(m,a)),d)}if(!t.eql(t.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function f(m){return typeof m=="bigint"&&W<m&&m<e.n}function u(m){if(!f(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function o(m){const{allowedPrivateKeyLengths:a,nByteLength:d,wrapPrivateKey:h,n:E}=e;if(a&&typeof m!="bigint"){if(et(m)&&(m=ot(m)),typeof m!="string"||!a.includes(m.length))throw new Error("Invalid key");m=m.padStart(d*2,"0")}let B;try{B=typeof m=="bigint"?m:rt(V("private key",m,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof m}`)}return h&&(B=z(B,E)),u(B),B}const c=new Map;function p(m){if(!(m instanceof y))throw new Error("ProjectivePoint expected")}class y{constructor(a,d,h){if(this.px=a,this.py=d,this.pz=h,a==null||!t.isValid(a))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(h==null||!t.isValid(h))throw new Error("z required")}static fromAffine(a){const{x:d,y:h}=a||{};if(!a||!t.isValid(d)||!t.isValid(h))throw new Error("invalid affine point");if(a instanceof y)throw new Error("projective point not allowed");const E=B=>t.eql(B,t.ZERO);return E(d)&&E(h)?y.ZERO:new y(d,h,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const d=t.invertBatch(a.map(h=>h.pz));return a.map((h,E)=>h.toAffine(d[E])).map(y.fromAffine)}static fromHex(a){const d=y.fromAffine(s(V("pointHex",a)));return d.assertValidity(),d}static fromPrivateKey(a){return y.BASE.multiply(o(a))}_setWindowSize(a){this._WINDOW_SIZE=a,c.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:a,y:d}=this.toAffine();if(!t.isValid(a)||!t.isValid(d))throw new Error("bad point: x or y not FE");const h=t.sqr(d),E=i(a);if(!t.eql(h,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){p(a);const{px:d,py:h,pz:E}=this,{px:B,py:A,pz:I}=a,w=t.eql(t.mul(d,I),t.mul(B,E)),b=t.eql(t.mul(h,I),t.mul(A,E));return w&&b}negate(){return new y(this.px,t.neg(this.py),this.pz)}double(){const{a,b:d}=e,h=t.mul(d,Tt),{px:E,py:B,pz:A}=this;let I=t.ZERO,w=t.ZERO,b=t.ZERO,S=t.mul(E,E),F=t.mul(B,B),R=t.mul(A,A),v=t.mul(E,B);return v=t.add(v,v),b=t.mul(E,A),b=t.add(b,b),I=t.mul(a,b),w=t.mul(h,R),w=t.add(I,w),I=t.sub(F,w),w=t.add(F,w),w=t.mul(I,w),I=t.mul(v,I),b=t.mul(h,b),R=t.mul(a,R),v=t.sub(S,R),v=t.mul(a,v),v=t.add(v,b),b=t.add(S,S),S=t.add(b,S),S=t.add(S,R),S=t.mul(S,v),w=t.add(w,S),R=t.mul(B,A),R=t.add(R,R),S=t.mul(R,v),I=t.sub(I,S),b=t.mul(R,F),b=t.add(b,b),b=t.add(b,b),new y(I,w,b)}add(a){p(a);const{px:d,py:h,pz:E}=this,{px:B,py:A,pz:I}=a;let w=t.ZERO,b=t.ZERO,S=t.ZERO;const F=e.a,R=t.mul(e.b,Tt);let v=t.mul(d,B),U=t.mul(h,A),P=t.mul(E,I),M=t.add(d,h),l=t.add(B,A);M=t.mul(M,l),l=t.add(v,U),M=t.sub(M,l),l=t.add(d,E);let g=t.add(B,I);return l=t.mul(l,g),g=t.add(v,P),l=t.sub(l,g),g=t.add(h,E),w=t.add(A,I),g=t.mul(g,w),w=t.add(U,P),g=t.sub(g,w),S=t.mul(F,l),w=t.mul(R,P),S=t.add(w,S),w=t.sub(U,S),S=t.add(U,S),b=t.mul(w,S),U=t.add(v,v),U=t.add(U,v),P=t.mul(F,P),l=t.mul(R,l),U=t.add(U,P),P=t.sub(v,P),P=t.mul(F,P),l=t.add(l,P),v=t.mul(U,l),b=t.add(b,v),v=t.mul(g,l),w=t.mul(M,w),w=t.sub(w,v),v=t.mul(M,U),S=t.mul(g,S),S=t.add(S,v),new y(w,b,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(y.ZERO)}wNAF(a){return L.wNAFCached(this,c,a,d=>{const h=t.invertBatch(d.map(E=>E.pz));return d.map((E,B)=>E.toAffine(h[B])).map(y.fromAffine)})}multiplyUnsafe(a){const d=y.ZERO;if(a===W)return d;if(u(a),a===j)return this;const{endo:h}=e;if(!h)return L.unsafeLadder(this,a);let{k1neg:E,k1:B,k2neg:A,k2:I}=h.splitScalar(a),w=d,b=d,S=this;for(;B>W||I>W;)B&j&&(w=w.add(S)),I&j&&(b=b.add(S)),S=S.double(),B>>=j,I>>=j;return E&&(w=w.negate()),A&&(b=b.negate()),b=new y(t.mul(b.px,h.beta),b.py,b.pz),w.add(b)}multiply(a){u(a);let d=a,h,E;const{endo:B}=e;if(B){const{k1neg:A,k1:I,k2neg:w,k2:b}=B.splitScalar(d);let{p:S,f:F}=this.wNAF(I),{p:R,f:v}=this.wNAF(b);S=L.constTimeNegate(A,S),R=L.constTimeNegate(w,R),R=new y(t.mul(R.px,B.beta),R.py,R.pz),h=S.add(R),E=F.add(v)}else{const{p:A,f:I}=this.wNAF(d);h=A,E=I}return y.normalizeZ([h,E])[0]}multiplyAndAddUnsafe(a,d,h){const E=y.BASE,B=(I,w)=>w===W||w===j||!I.equals(E)?I.multiplyUnsafe(w):I.multiply(w),A=B(this,d).add(B(a,h));return A.is0()?void 0:A}toAffine(a){const{px:d,py:h,pz:E}=this,B=this.is0();a==null&&(a=B?t.ONE:t.inv(E));const A=t.mul(d,a),I=t.mul(h,a),w=t.mul(E,a);if(B)return{x:t.ZERO,y:t.ZERO};if(!t.eql(w,t.ONE))throw new Error("invZ was invalid");return{x:A,y:I}}isTorsionFree(){const{h:a,isTorsionFree:d}=e;if(a===j)return!0;if(d)return d(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:d}=e;return a===j?this:d?d(y,this):this.multiplyUnsafe(e.h)}toRawBytes(a=!0){return this.assertValidity(),n(y,this,a)}toHex(a=!0){return ot(this.toRawBytes(a))}}y.BASE=new y(e.Gx,e.Gy,t.ONE),y.ZERO=new y(t.ZERO,t.ONE,t.ZERO);const O=e.nBitLength,L=br(y,e.endo?Math.ceil(O/2):O);return{CURVE:e,ProjectivePoint:y,normPrivateKeyToScalar:o,weierstrassEquation:i,isWithinCurveOrder:f}}function vr(r){const e=jt(r);return lt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ar(r){const e=vr(r),{Fp:t,n}=e,s=t.BYTES+1,i=2*t.BYTES+1;function f(l){return W<l&&l<t.ORDER}function u(l){return z(l,n)}function o(l){return Et(l,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:p,weierstrassEquation:y,isWithinCurveOrder:O}=Ir({...e,toBytes(l,g,x){const N=g.toAffine(),H=t.toBytes(N.x),q=ut;return x?q(Uint8Array.from([g.hasEvenY()?2:3]),H):q(Uint8Array.from([4]),H,t.toBytes(N.y))},fromBytes(l){const g=l.length,x=l[0],N=l.subarray(1);if(g===s&&(x===2||x===3)){const H=rt(N);if(!f(H))throw new Error("Point is not on curve");const q=y(H);let k;try{k=t.sqrt(q)}catch(Z){const D=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+D)}const K=(k&j)===j;return(x&1)===1!==K&&(k=t.neg(k)),{x:H,y:k}}else if(g===i&&x===4){const H=t.fromBytes(N.subarray(0,t.BYTES)),q=t.fromBytes(N.subarray(t.BYTES,2*t.BYTES));return{x:H,y:q}}else throw new Error(`Point of length ${g} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)}}),L=l=>ot(st(l,e.nByteLength));function m(l){const g=n>>j;return l>g}function a(l){return m(l)?u(-l):l}const d=(l,g,x)=>rt(l.slice(g,x));class h{constructor(g,x,N){this.r=g,this.s=x,this.recovery=N,this.assertValidity()}static fromCompact(g){const x=e.nByteLength;return g=V("compactSignature",g,x*2),new h(d(g,0,x),d(g,x,2*x))}static fromDER(g){const{r:x,s:N}=tt.toSig(V("DER",g));return new h(x,N)}assertValidity(){if(!O(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!O(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(g){return new h(this.r,this.s,g)}recoverPublicKey(g){const{r:x,s:N,recovery:H}=this,q=b(V("msgHash",g));if(H==null||![0,1,2,3].includes(H))throw new Error("recovery id invalid");const k=H===2||H===3?x+e.n:x;if(k>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const K=H&1?"03":"02",Z=c.fromHex(K+L(k)),D=o(k),G=u(-q*D),ft=u(N*D),J=c.BASE.multiplyAndAddUnsafe(Z,G,ft);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,u(-this.s),this.recovery):this}toDERRawBytes(){return it(this.toDERHex())}toDERHex(){return tt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return it(this.toCompactHex())}toCompactHex(){return L(this.r)+L(this.s)}}const E={isValidPrivateKey(l){try{return p(l),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const l=Ct(e.n);return mr(e.randomBytes(l),e.n)},precompute(l=8,g=c.BASE){return g._setWindowSize(l),g.multiply(BigInt(3)),g}};function B(l,g=!0){return c.fromPrivateKey(l).toRawBytes(g)}function A(l){const g=et(l),x=typeof l=="string",N=(g||x)&&l.length;return g?N===s||N===i:x?N===2*s||N===2*i:l instanceof c}function I(l,g,x=!0){if(A(l))throw new Error("first arg must be private key");if(!A(g))throw new Error("second arg must be public key");return c.fromHex(g).multiply(p(l)).toRawBytes(x)}const w=e.bits2int||function(l){const g=rt(l),x=l.length*8-e.nBitLength;return x>0?g>>BigInt(x):g},b=e.bits2int_modN||function(l){return u(w(l))},S=vt(e.nBitLength);function F(l){if(typeof l!="bigint")throw new Error("bigint expected");if(!(W<=l&&l<S))throw new Error(`bigint expected < 2^${e.nBitLength}`);return st(l,e.nByteLength)}function R(l,g,x=v){if(["recovered","canonical"].some(X=>X in x))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:H}=e;let{lowS:q,prehash:k,extraEntropy:K}=x;q==null&&(q=!0),l=V("msgHash",l),k&&(l=V("prehashed msgHash",N(l)));const Z=b(l),D=p(g),G=[F(D),F(Z)];if(K!=null&&K!==!1){const X=K===!0?H(t.BYTES):K;G.push(V("extraEntropy",X))}const ft=ut(...G),J=Z;function dt(X){const at=w(X);if(!O(at))return;const ht=o(at),Y=c.BASE.multiply(at).toAffine(),nt=u(Y.x);if(nt===W)return;const gt=u(ht*u(J+nt*D));if(gt===W)return;let At=(Y.x===nt?0:2)|Number(Y.y&j),Ot=gt;return q&&m(gt)&&(Ot=a(gt),At^=1),new h(nt,Ot,At)}return{seed:ft,k2sig:dt}}const v={lowS:e.lowS,prehash:!1},U={lowS:e.lowS,prehash:!1};function P(l,g,x=v){const{seed:N,k2sig:H}=R(l,g,x),q=e;return kt(q.hash.outputLen,q.nByteLength,q.hmac)(N,H)}c.BASE._setWindowSize(8);function M(l,g,x,N=U){var H;const q=l;if(g=V("msgHash",g),x=V("publicKey",x),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:K}=N;let Z,D;try{if(typeof q=="string"||et(q))try{Z=h.fromDER(q)}catch(Y){if(!(Y instanceof tt.Err))throw Y;Z=h.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:Y,s:nt}=q;Z=new h(Y,nt)}else throw new Error("PARSE");D=c.fromHex(x)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&Z.hasHighS())return!1;K&&(g=e.hash(g));const{r:G,s:ft}=Z,J=b(g),dt=o(ft),X=u(J*dt),at=u(G*dt),ht=(H=c.BASE.multiplyAndAddUnsafe(D,X,at))==null?void 0:H.toAffine();return ht?u(ht.x)===G:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:I,sign:P,verify:M,ProjectivePoint:c,Signature:h,utils:E}}class Vt extends Mt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Gt(e);const n=Jt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let f=0;f<i.length;f++)i[f]^=54;this.iHash.update(i),this.oHash=e.create();for(let f=0;f<i.length;f++)i[f]^=106;this.oHash.update(i),i.fill(0)}update(e){return qt(this),this.iHash.update(e),this}digestInto(e){qt(this),Xt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:f,outputLen:u}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=f,e.outputLen=u,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Kt=(r,e,t)=>new Vt(r,e).update(t).digest();Kt.create=(r,e)=>new Vt(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Or(r){return{hash:r,hmac:(e,...t)=>Kt(r,e,Yt(...t)),randomBytes:_t}}function qr(r,e){const t=n=>Ar({...r,...Or(n)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Rr=BigInt(1),bt=BigInt(2),zt=(r,e)=>(r+e/bt)/e;function Nr(r){const e=Dt,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),f=BigInt(23),u=BigInt(44),o=BigInt(88),c=r*r*r%e,p=c*c*r%e,y=C(p,t,e)*p%e,O=C(y,t,e)*p%e,L=C(O,bt,e)*c%e,m=C(L,s,e)*L%e,a=C(m,i,e)*m%e,d=C(a,u,e)*a%e,h=C(d,o,e)*d%e,E=C(h,u,e)*a%e,B=C(E,t,e)*p%e,A=C(B,f,e)*m%e,I=C(A,n,e)*c%e,w=C(I,bt,e);if(!Bt.eql(Bt.sqr(w),r))throw new Error("Cannot find square root");return w}const Bt=wr(Dt,void 0,void 0,{sqrt:Nr}),Hr=qr({a:BigInt(0),b:BigInt(7),Fp:Bt,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Lt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Rr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,f=BigInt("0x100000000000000000000000000000000"),u=zt(i*r,e),o=zt(-n*r,e);let c=z(r-u*t-o*s,e),p=z(-u*n-o*i,e);const y=c>f,O=p>f;if(y&&(c=e-c),O&&(p=e-p),c>f||p>f)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:y,k1:c,k2neg:O,k2:p}}}},Wt);BigInt(0);Hr.ProjectivePoint;export{Hr as secp256k1};
